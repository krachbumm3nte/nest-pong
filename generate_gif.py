import numpy as np
from PIL import Image
from PIL import ImageFont
from PIL import ImageDraw 
import pickle
import matplotlib.pyplot as plt
import gzip
import os
import io
import sys
from copy import copy
import pong

# base colors used in the plot
background_color = (220, 220, 220) # grey
background_hex = "#dcdcdc" # hex value of the same color, required for matplotlib
black = np.array((0, 0, 0))
white = np.array((255, 255, 255))
left_color = np.array((204, 0, 153)) # purple
right_color = np.array((255, 128, 0)) # orange

# final output image size
IMAGE_SIZE = np.array([400, 320])
# original size of the playing field inside the simulation
FIELD_SIZE = np.array([pong.GameOfPong.x_grid, pong.GameOfPong.y_grid]) 

FIELD_SCALE = 8
# Field size (in px) in the final image
FIELD_SIZE_SCALED = FIELD_SIZE * FIELD_SCALE 


# dimensions of game objects in px
BALL_RAD = 2
PADDLE_LEN = int(0.1*FIELD_SIZE_SCALED[1])
PADDLE_WID = 6

# Add margins left and right to the image representing the playing field 
FIELD_PADDING = PADDLE_WID * 2
FIELD_IMAGE_SIZE = copy(FIELD_SIZE_SCALED)
FIELD_IMAGE_SIZE[0] += 2*FIELD_PADDING

HEATMAP_SCALE = 4
# weight matrix heatmap size (in px) in the final image
HEATMAP_SIZE = np.array([FIELD_SIZE[1], FIELD_SIZE[1]]) * HEATMAP_SCALE

DEFAULT_SPEED = 4
PLOT_INTERVAL = 10

def scale_coordinates(coordinates: np.array):
    """Scale an (x,y) coordinate tuple from simulation scale to a pixel coordinate in the output image

    Args:
        pos (float, float): input coordinates to be scaled

    Returns:
        (int, int): output coordinates in pixel value
    """
    coordinates[:,0] = coordinates[:,0] * FIELD_SIZE_SCALED[0] / pong.GameOfPong.x_length + FIELD_PADDING
    coordinates[:,1] = coordinates[:,1] * FIELD_SIZE_SCALED[1] / pong.GameOfPong.y_length
    coordinates = coordinates.astype(int)
    return coordinates

def grayscale_to_heatmap(in_image, min_val, max_val, base_color):
    """transform a weight matrix to an RGB heat map. Heatmap will color small values in base_color and high values white

    Args:
        in_image (numpy.array): 2D numpy.array to be transformed
        min_val (float): smallest value across the entire dataset - colored in base_color in the output
        max_val (float): largest value across the entire dataset - colored white (255, 255, 255)
        base_color (numpy.array): numpy.array of shape (3,) representing the base color of the heatmap in RGB space
    Returns:
        numpy.array: transformed input array with an added 3rd dimension of length three representing RGB values
    """
    x_len, y_len = in_image.shape
    out_image = np.zeros((x_len, y_len, 3), dtype=np.uint8)

    span = max_val - min_val + 0.0001 # add miniscule offsett to avoid zero division error for uniform weight matrix
    for i in range(x_len):
        for j in range(y_len):
            val = (in_image[i,j] - min_val) / span
            out_image[i,j, :] = base_color + (white-base_color) * val
    return out_image

#%%

if __name__ == "__main__":

    if len(sys.argv) != 2:
        print("This programm takes exactly one argument - the location of the output folder generated by the pang.py simulation.")
        sys.exit()
    
    input_folder = sys.argv[1]
    

    font_name = "DejaVuSansCondensed.ttf"
    try:
        font_large = ImageFont.truetype(font_name, 26, encoding="unic")
        font_medium = ImageFont.truetype(font_name, 18, encoding="unic")
    except OSError:
        print(f"Could not find font <{font_name}> on your machine, falling back to default font.")
        font_large = ImageFont.load_default()
        font_medium = ImageFont.load_default()


    with open(os.path.join(input_folder, "gamestate.pkl"), 'rb') as f:
        game_data = pickle.load(f)

    ball_positions = scale_coordinates(np.array(game_data["ball_pos"]))
    l_paddle_positions = scale_coordinates(np.array(game_data["left_paddle"]))
    l_paddle_positions[:,0] -= PADDLE_WID # move left paddle outwards for symmetry
    r_paddle_positions = scale_coordinates(np.array(game_data["right_paddle"]))
    score = np.array(game_data["score"]).astype(int)

    with gzip.open(os.path.join(input_folder, "data_right.pkl.gz"), 'r') as f:
        data = pickle.load(f)
        rewards_right = data["rewards"]
        weights_right = data["weights"]
        
    with gzip.open(os.path.join(input_folder, "data_left.pkl.gz"), 'r') as f:
        data = pickle.load(f)
        rewards_left = data["rewards"]
        weights_left = data["weights"]

    # extract lowest and highest weights for both players to scale the heatmaps correctly
    min_r, max_r = np.min(weights_right), np.max(weights_right)
    min_l, max_l = np.min(weights_left), np.max(weights_left)

    rewards_left = [np.mean(x) for x in rewards_left]
    rewards_right = [np.mean(x) for x in rewards_right]

    #TODO: param?
    out_folder = "images"
    if os.path.exists(out_folder):
        print("output folder already exists, aborting!")
        sys.exit()
    else:
        os.mkdir(out_folder)

    sim_iterations = score.shape[0]
    i = 0
    output_speed = DEFAULT_SPEED

    while i < sim_iterations:

        background = Image.new("RGB", tuple(IMAGE_SIZE), background_color)
        draw = ImageDraw.Draw(background)

        # create an empty array for the playing field.
        playing_field = np.zeros((FIELD_IMAGE_SIZE[0], FIELD_IMAGE_SIZE[1], 3), dtype=np.uint8)

        # draw Ball in white
        x, y = ball_positions[i]
        playing_field[x-BALL_RAD:x+BALL_RAD, y-BALL_RAD:y+BALL_RAD] = white

        for (x,y), color in zip([l_paddle_positions[i], r_paddle_positions[i]], [left_color, right_color]):
            #TODO: clip
            y = max(PADDLE_LEN, y)
            y = min(FIELD_IMAGE_SIZE[1] - PADDLE_LEN, y)
            playing_field[x:x+PADDLE_WID,y-PADDLE_LEN:y+PADDLE_LEN] = color

        # prepare and paste playing field into image
        playing_field = np.swapaxes(playing_field, 0, 1)
        playing_field = Image.fromarray(playing_field)
        background.paste(playing_field, (int((IMAGE_SIZE[0]-FIELD_IMAGE_SIZE[0])/2), 36))

        # only draw reward plot and heatmaps every PLOT_INTERVAL iterations or every frame when skipping many frames
        if i % PLOT_INTERVAL == 0 or output_speed > 10:
            plt.close()

            # Right player heatmap
            heatmap_r = grayscale_to_heatmap(weights_right[i], min_r, max_r, right_color) # convert weight to heatmap value
            heatmap_r = np.kron(heatmap_r, np.ones((HEATMAP_SCALE, HEATMAP_SCALE, 1), np.uint8)) # scale up array
            heatmap_r = Image.fromarray(heatmap_r)

            # Left player heatmap
            heatmap_l = grayscale_to_heatmap(weights_left[i], min_l, max_l, left_color)
            heatmap_l = np.kron(heatmap_l, np.ones((HEATMAP_SCALE, HEATMAP_SCALE, 1), np.uint8))
            heatmap_l = Image.fromarray(heatmap_l)

            # Plot rewards for both players
            fig = plt.figure(facecolor=background_hex)
            ax = plt.axes()
            ax.set_facecolor(background_hex)
            plt.rcParams["figure.autolayout"] = True
            plt.rcParams["font.size"] = 8
            #plt.xlabel("iteration")
            plt.ylabel("mean reward")
            ax.plot(rewards_right[:i+1], color=right_color/255)
            ax.plot(rewards_left[:i+1], color=left_color/255)
            
            ax.set_ylim(0,1.0)
            x_min = 0 if i < 2000 else i-2000
            ax.set_xlim(x_min, i)
            
            # set a constant figsize by pixel size
            DPI = fig.get_dpi()
            fig.set_size_inches(210.0/float(DPI),120.0/float(DPI))

            # fishy workaround to turn a pyplot figure into a PIL.Image
            buf = io.BytesIO()
            fig.savefig(buf)
            buf.seek(0)
            reward_plot = Image.open(buf)
        
        background.paste(heatmap_r, (310, 210))
        draw.text((315, 290), "weights", tuple(black), font_medium)

        background.paste(heatmap_l, (10, 210))  
        draw.text((15, 290), "weights", tuple(black), font_medium)

        if i > PLOT_INTERVAL:
            # only start plotting rewards after the first few iterations
            background.paste(reward_plot, (95, 200))

        draw.text((75, 10), "clean input", tuple(left_color), font_medium)
        draw.text((188, 10), "VS", tuple(black), font_medium)
        draw.text((235, 10), "noisy input", tuple(right_color), font_medium)

        
        l_score, r_score = score[i]
        draw.text((20, 100), str(l_score), tuple(black), font_large)
        draw.text((350, 100), str(r_score), tuple(black), font_large)

        draw.text((10,5), "run:", tuple(black), font_medium)
        draw.text((10,30), str(i), tuple(black), font_medium)

        draw.text((345, 5), f"speed:", tuple(black), font_medium)
        draw.text((345, 30), str(output_speed)+'x', tuple(black), font_medium)

        background.save(os.path.join(out_folder, f"img_{str(i).zfill(6)}.png"))

        # change the speed of the video to show performance before and after training at DEFAULT_SPEED
        # and fast forward most of the training
        if 100 <= i < 150 or 3700 <= i < 3750:
            output_speed = 10
        elif 150 <= i < 3700:
            output_speed = 50
        else:
            output_speed = DEFAULT_SPEED
        
        i+=output_speed




